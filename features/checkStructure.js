const vscode = require("vscode");
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const fs = require("fs");
const path = require("path");

async function runStructureCheck() {
  const editor = vscode.window.activeTextEditor;
  if (!editor) return vscode.window.showWarningMessage("No active file");

  const document = editor.document;
  const fileUri = document.uri;

  if (document.isUntitled) {
    return vscode.window.showErrorMessage("âŒ Please save the file first.");
  }

  if (document.isDirty) {
    const save = await vscode.window.showInformationMessage(
      "ğŸ’¾ Unsaved changes detected. Save before analysing?",
      "Save and Continue",
      "Cancel"
    );
    if (save !== "Save and Continue") return;
    await document.save();
  }

  const code = document.getText();
  const lines = code.split("\n").length;
  let ast;

  try {
    ast = parser.parse(code, {
      sourceType: "module",
      plugins: ["jsx", "typescript"],
      ranges: true,
      tokens: true,
      errorRecovery: true,
      attachComment: true,
    });
  } catch (err) {
    return vscode.window.showErrorMessage("âŒ Could not parse JS file.");
  }

  // Analysis
  let topLevelFunctions = 0;
  let allFunctions = [];
  let largeFunctions = [];
  let undocumented = [];

  traverse(ast, {
    FunctionDeclaration(path) {
      if (path.parent.type === "Program") {
        topLevelFunctions++;
      }

      const start = path.node.loc.start.line;
      const end = path.node.loc.end.line;
      const size = end - start;
      const name = path.node.id?.name || "anonymous function";

      allFunctions.push({ name, lines: size, lineStart: start, lineEnd: end });

      if (size > 50) {
        largeFunctions.push({
          name,
          lines: size,
          lineStart: start,
          lineEnd: end,
        });
      }

      const leading = path.node.leadingComments || [];
      const hasJSDoc = leading.some((comment) => comment.value.startsWith("*"));
      if (!hasJSDoc) {
        undocumented.push({ name, line: start });
      }
    },
  });

  const longestFn = allFunctions.sort((a, b) => b.lines - a.lines)[0];
  const avgFnLength =
    allFunctions.length > 0
      ? (
          allFunctions.reduce((sum, fn) => sum + fn.lines, 0) /
          allFunctions.length
        ).toFixed(1)
      : "N/A";

  // Comment Density
  const commentLines = code
    .split("\n")
    .filter(
      (line) =>
        line.trim().startsWith("//") ||
        line.trim().startsWith("/*") ||
        line.trim().startsWith("*")
    ).length;
  const commentDensity = ((commentLines / lines) * 100).toFixed(1);

  // Summary + Health Score
  let issueCount = 0;
  if (topLevelFunctions > 3) issueCount++;
  if (largeFunctions.length > 0) issueCount++;
  if (undocumented.length > 0) issueCount++;

  const healthScore = Math.max(0, 100 - (issueCount / 5) * 100);

  // Time + Filename
  const fileName = path.basename(fileUri.fsPath);
  const baseName = path.basename(fileUri.fsPath, path.extname(fileUri.fsPath));
  const now = new Date();
  const timestampDisplay = now.toLocaleString("en-GB", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
  const timestampFile = `${now.getFullYear()}-${String(
    now.getMonth() + 1
  ).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")}_${String(
    now.getHours()
  ).padStart(2, "0")}-${String(now.getMinutes()).padStart(2, "0")}`;
  const reportFileName = `${baseName}-report-${timestampFile}.md`;

  // Markdown Sections
  const undocumentedMd = undocumented
    .map((fn) => `- \`${fn.name}\` (line ${fn.line})`)
    .join("\n");
  const largeFnsMd = largeFunctions
    .map(
      (fn) =>
        `- \`${fn.name}\` (${fn.lines} lines, lines ${fn.lineStart}-${fn.lineEnd})`
    )
    .join("\n");

  const reportContent = `# ğŸ“ Structure Analysis Report: ${fileName}
_Generated by PwC JS Refactor Tool_

---

## ğŸ“Š File Summary

- ğŸ“„ File Length: **${lines} lines**
- ğŸ”§ Top-Level Functions: **${topLevelFunctions}**
- ğŸ“ Longest Function: \`${longestFn.name}\` (${longestFn.lines} lines, lines ${
    longestFn.lineStart
  }-${longestFn.lineEnd})
- ğŸ“ Average Function Length: **${avgFnLength} lines**
- ğŸ—’ï¸ Comment Density: **${commentDensity}%**

---

## â¤ï¸ Health Score
âœ… **${healthScore.toFixed(
    0
  )}%** â€” Based on analysis of structural best practices

---

## ğŸ§  Findings (With Severity)

${
  undocumented.length > 0
    ? `- ğŸ”´ **High:** ${undocumented.length} undocumented function(s)`
    : ""
}
${
  topLevelFunctions > 3
    ? `- ğŸŸ¡ **Medium:** ${topLevelFunctions} top-level functions (suggest modularisation)`
    : ""
}
${
  largeFunctions.length > 0
    ? `- ğŸŸ¡ **Medium:** ${largeFunctions.length} large function(s)`
    : ""
}

---

<details>
<summary>ğŸ“š Undocumented Functions (Click to expand)</summary>

${undocumentedMd || "- None"}

</details>

<details>
<summary>ğŸ“ Large Functions (Click to expand)</summary>

${largeFnsMd || "- None"}

</details>

---

ğŸ’¡ **Tip:** Consider adding JSDoc comments (\`/** */\`) above functions for maintainability.

[â†© Back to Summary](#ğŸ“Š-file-summary)

---

ğŸ•’ **Report generated on:** ${timestampDisplay}
`;

  // ğŸ—‚ï¸ Save to structure-reports folder
  const reportDir = path.join(
    path.dirname(fileUri.fsPath),
    "structure-reports"
  );
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir);
  }
  const reportPath = path.join(reportDir, reportFileName);
  fs.writeFileSync(reportPath, reportContent);

  const reportUri = vscode.Uri.file(reportPath);
  await vscode.commands.executeCommand("markdown.showPreviewToSide", reportUri);

  vscode.window.showInformationMessage(
    `ğŸ“„ Structure analysis complete. Report saved as ${reportFileName}`
  );
}

module.exports = {
  run: runStructureCheck,
};